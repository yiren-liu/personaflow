import { useContext, useEffect, useState } from "react"

import Button from "@mui/material/Button"
import { Box, Modal, Tooltip, Typography } from "@mui/material"

import { InteractiveTutorialContext } from "../../../../contexts/InteractiveTutorialContext"
import { TabsContext } from "../../../../contexts/tabsContext"
import { typesContext } from "../../../../contexts/typesContext"
import { Edge } from "reactflow"
import { NodeDataType, NodeType } from "../../../../types/flow"
import { contextMenuContext } from "../../../../contexts/contextMenuContext"
import {
  APIClassType,
  CritiqueNodeData,
  NodeData,
  PersonaNodeData,
  RQNodeData,
} from "../../../../types/api"
import {
  // getCritiqueRQ,
  // getLitQuery,
  // getPaperInfoSearch,
  // getPersonaCritique,
  // getRQPersona,
  useApi,
} from "../../../../controllers/API"
import * as _ from "lodash"
import { formatPersonaData } from "../../../../ContextMenus/utils"

export default function InteractiveTutorialComponent({
  children,
  targetTutorialStep,
  additionalData,
  childNodeId,
}: {
  children: React.ReactNode
  targetTutorialStep?: number
  additionalData?: any
  childNodeId?: string
}) {
  const {
    getCritiqueRQ,
    getLitQuery,
    getPaperInfoSearch,
    getPersonaCritique,
    getRQPersona,
  } = useApi()
  const {
    isInteractiveTutorialOpen,
    setIsInteractiveTutorialOpen,
    interactiveTutorialSteps,
    setIsInteractiveTutorialDone,
    currentStep,
    setCurrentStep,
    targetNodeIds,
    setTargetNodeIds,
  } = useContext(InteractiveTutorialContext)

  const {
    isNodeMenuOpen,
    setIsNodeMenuOpen,
    isEdgeMenuOpen,
    setIsEdgeMenuOpen,
    edgeContextMenuPostion,
    setEdgeContextMenuPostion,
    nodeContextMenuPostion,
    setNodeContextMenuPostion,
    contextMenuNode,
    setContextMenuNode,
    // contextMenuEdge, setContextMenuEdge,

    setLoadingForNode,
  } = useContext(contextMenuContext)

  const { currentNode, setCurrentNode } = useContext(contextMenuContext)

  let { incrementNodeId, tabIndex, flows, updateFlow } = useContext(TabsContext)
  const {
    reactFlowInstance,
    addNodes,
    addEdges,
    templates,
    getNodeAllAncestors,
  } = useContext(typesContext)

  const NODETYPES = templates

  const createNodeAndConnect = (
    node_type: string = "genericNode",
    target_node_id: string = contextMenuNode.id,
    node_datas: any[] = null,
    command_name: string = null,
  ) => {
    let num = node_datas.length
    let node = reactFlowInstance
      .getNodes()
      .filter((n: Node) => n.id === target_node_id)[0]

    console.log("createRQNodesAndConnect: ")

    // Helper function to generate a unique node ID
    function getId() {
      return `dndnode_` + incrementNodeId()
    }

    let newNodes = []
    let newEdges = []
    let nodeIDs = []
    for (let i = 0; i < num; i++) {
      // Get the position of the target node
      const nodePosition = { ...node.position }
      // offset the position a bit
      nodePosition.x += 1000
      nodePosition.y += i * 300 - 300 // increment y position by 300 for each node

      // Generate a unique node ID
      let newId = getId()
      nodeIDs.push(newId)

      // Create the new node
      if (node_type === "genericNode" || node_type === "RQNode") {
        let nodeData: NodeDataType = {
          node: {
            ..._.cloneDeep(NODETYPES["RQNode"]),
          } as unknown as APIClassType,
          type: "RQNode",
          id: newId,
          value: null,
          filterIDs: null,
          lockedIDs: contextMenuNode.data.lockedIDs, // inherit from parent node
          userInput: null,
          valueDict: {},
          autoGenerated: true,
        }
        // nodeData.value = texts[i];
        // nodeData.value = node_datas[i].rq_text;
        // nodeData.node.template.RQ.value = node_datas[i].rq_text;
        nodeData.userInput = node_datas[i].rq_text
        let newNode = {
          id: newId,
          type: "RQNode",
          position: nodePosition,
          data: {
            ...nodeData,
          },
        }

        newNodes.push(newNode)

        // set target node's id
        setTargetNodeIds([newId])
        // setCurrentNode(newNode)
      } else if (node_type === "PersonaNode") {
        let nodeData: NodeDataType = {
          node: {
            ..._.cloneDeep(NODETYPES["PersonaNode"]),
          } as unknown as APIClassType,
          type: "PersonaNode",
          id: newId,
          value: null,
          filterIDs: null,
          lockedIDs: contextMenuNode.data.lockedIDs, // inherit from parent node
          userInput: null,
          valueDict: {},
        }
        nodeData.node.template.persona_name.value = node_datas[i].persona_name
        // nodeData.node.template.persona_description.value =
        //   node_datas[i].persona_description
        nodeData.node.template.roleTasks = node_datas[i].persona_description["role_fields"] || []
        nodeData.node.template.background = node_datas[i].persona_description["background_fields"] || []
        let newNode = {
          id: newId,
          type: "PersonaNode",
          position: nodePosition,
          data: {
            ...nodeData,
          },
        }

        newNodes.push(newNode)

        // set target node's id
        setTargetNodeIds([newId])
        setCurrentNode(newNode)
      } else if (node_type === "CritiqueNode") {
        let nodeData: NodeDataType = {
          node: {
            ..._.cloneDeep(NODETYPES["CritiqueNode"]),
          } as unknown as APIClassType,
          type: "CritiqueNode",
          id: newId,
          value: null,
          filterIDs: null,
          lockedIDs: contextMenuNode.data.lockedIDs, // inherit from parent node
          userInput: null,
          valueDict: {},
        }
        nodeData.node.template.critique_aspect.value =
          node_datas[i].critique_aspect
        nodeData.node.template.critique_detail.value =
          node_datas[i].critique_detail
        let newNode = {
          id: newId,
          type: "CritiqueNode",
          position: nodePosition,
          data: {
            ...nodeData,
          },
        }

        newNodes.push(newNode)

        // set target node's id
        setTargetNodeIds([newId])
        setCurrentNode(newNode)
      } else if (node_type === "LiteratureNode") {
        let nodeData: NodeDataType = {
          node: {
            ..._.cloneDeep(NODETYPES["LiteratureNode"]),
          } as unknown as APIClassType,
          type: "LiteratureNode",
          id: newId,
          value: null,
          filterIDs: null,
          lockedIDs: contextMenuNode.data.lockedIDs, // inherit from parent node
          userInput: null,
          valueDict: {},
        }
        nodeData.node.template.paper_list.name = node_datas[i].query
        nodeData.node.template.paper_list.value = node_datas[i].paper_list
        let newNode = {
          id: newId,
          type: "LiteratureNode",
          position: nodePosition,
          data: {
            ...nodeData,
          },
        }

        newNodes.push(newNode)

        // set target node's id
        setTargetNodeIds([newId])
        // setCurrentNode(newNode)
      }

      // create an edge between the target node and the new node
      let params = {
        source: node.id,
        sourceHandle: `RQ Node|${node.id}|RQNode`,
        target: newId,
        targetHandle: `RQNode|llm|${newId}`,
        labelStyle: {
          fill: "orange",
          fontWeight: 700,
          // "fontSize": 12,
        },
        id: `edge_${node.id}_${newId}`,
        // "edgeUpdaterRadius": 0,
        // "data": {
        //     "command_results": command_result,
        // },
        // type: "smoothstep",
      }
      let newEdge: Edge = {
        ...params,
        className: "animate-pulse",
      } as unknown as Edge
      newEdges.push(newEdge)
    }

    // add the new nodes and edges to the flow
    addNodes(newNodes)
    addEdges(newEdges)

    setIsNodeMenuOpen(false)

    return [nodeIDs, newNodes]
  }

  function getId() {
    return `dndnode_` + incrementNodeId()
  }

  const generateRQ = () => {
    const position = reactFlowInstance.project({
      x: 100,
      y: 300,
    })
    let newId = getId()
    let nodeType = additionalData.type
    const newNode: NodeType = {
      id: newId,
      type: nodeType,
      position,
      data: {
        ...additionalData,
        id: newId,
        value: null,
        filterIDs: null,
        lockedIDs: [],
        userInput: null,
        valueDict: {},
        autoGenerated: nodeType === "RQNode" ? false : undefined,
      },
    }
    addNodes([newNode])
  }

  const generatePersonaFromRQ = () => {
    const rq_data = {
      rq_text: contextMenuNode?.data?.userInput,
    } as RQNodeData

    setLoadingForNode(contextMenuNode?.id, true)

    const ancestorNodesWithDepth = getNodeAllAncestors(contextMenuNode)
    getRQPersona(rq_data, ancestorNodesWithDepth)
      .then((result) => {
        console.log("getCritiqueRQ: ", result.data)

        // create a new node, and fill the value with the critique
        let [newNodeIDs, newNodes] = createNodeAndConnect(
          "PersonaNode",
          contextMenuNode.id,
          result.data,
          "None",
        )
      })
      .catch((error) => {
        console.log("getPersonaCritique: ", error)
      })
      .finally(() => {
        setLoadingForNode(contextMenuNode.id, false)
        setCurrentStep(currentStep + 1)
      })
  }

  const generateLitNodesFromQueries = (queries: string[]) => {
    let newNodesData: any[] = []
    let queriesPromises = queries.map((query) => getPaperInfoSearch(query))
    Promise.all(queriesPromises)
      .then((results) => {
        results.forEach((result) => {
          console.log("getPaperInfoSearch: ", result.data)
          // create a new node, and fill the value with the critique
          newNodesData.push({
            paper_list: result.data.paper_list,
            query: result.data.query,
          })
        })
      })
      .finally(() => {
        // clean newNodesData
        newNodesData = newNodesData.filter((item) => item.paper_list.length > 0)

        let [newNodeIDs, newNodes] = createNodeAndConnect(
          "LiteratureNode",
          contextMenuNode.id,
          newNodesData,
          "generateLitNodesFromQueries",
        )
        setLoadingForNode(contextMenuNode.id, false)
      })
  }

  const generateLitNodesFromPersona = () => {
    const ancestorNodesWithDepth = getNodeAllAncestors(contextMenuNode)
    const ancestorNodes = ancestorNodesWithDepth.map((item) => item.node)
    const ancestorRQNodes = ancestorNodes.filter(
      (node) => node.data.type === "RQNode",
    )

    const rqNode = ancestorRQNodes[0]
    const rqData = {
      rq_text: rqNode.data.userInput,
    } as NodeData

    let personaData: PersonaNodeData[] = []

    // if the current node is not a group node
    contextMenuNode.data.node.template.persona_description.value = formatPersonaData(contextMenuNode);
    personaData = personaData.concat({
      persona_name: contextMenuNode.data.node.template.persona_name.value,
      persona_description:
        contextMenuNode.data.node.template.persona_description.value,
    })

    setLoadingForNode(contextMenuNode.id, true)
    getLitQuery(rqData, personaData, ancestorNodesWithDepth)
      .then((result) => {
        console.log("getLitQuery: ", result.data) // [{'search_query': '...'}, ...]

        // TODO: based on the query, use search papers API to retrieve paper IDs, and create new LiteratureNodes
        const queries = result.data.map((item) => item.search_query)
        generateLitNodesFromQueries(queries)
      })
      .catch((error) => {
        console.log("getLitQuery: ", error)
      })
      .finally(() => {
        // setLoadingForNode(contextMenuNode.id, false);
        setCurrentStep(currentStep + 1)
      })
  }

  const generateCritiqueFromLiterature = () => {
    const literatureData =
      contextMenuNode.data.node.template.paper_list.value.filter(
        (item) => typeof item === "object" && item !== null,
      )

    const ancestorNodesWithDepth = getNodeAllAncestors(contextMenuNode)
    const ancestorNodes = ancestorNodesWithDepth.map((item) => item.node)
    const ancestorPersonaNodes = ancestorNodes.filter(
      (node) => node.data.type === "PersonaNode",
    )

    // include self as a ancestor node, with depth=1 as the first of the list
    ancestorNodesWithDepth.unshift({
      node: contextMenuNode,
      depth: 1,
    })

    if (ancestorPersonaNodes.length === 0) {
      console.log("no persona node found")

      return
    }

    let personaData: PersonaNodeData[] = []
    if (ancestorPersonaNodes[0].type === "group") {
      // if the current node is a group node

      return
    } else {
      // if the current node is not a group node
      ancestorPersonaNodes[0].data.node.template.persona_description.value = formatPersonaData(ancestorPersonaNodes[0]);
      personaData = personaData.concat({
        persona_name:
          ancestorPersonaNodes[0].data.node.template.persona_name.value,
        persona_description:
          ancestorPersonaNodes[0].data.node.template.persona_description.value,
      })
    }

    let rqNode: NodeType | null = null
    let rqData: NodeData = {} as NodeData
    const ancestorRQNodes = ancestorNodes.filter(
      (node) => node.data.type === "RQNode",
    )
    if (ancestorRQNodes.length > 0) {
      rqNode = ancestorRQNodes[0]
    } else {
      console.log("no rq node found")

      return
    }
    if (rqNode) {
      rqData = {
        rq_text: rqNode.data.userInput,
      } as NodeData
    } else {
      console.log("RQ node is null")

      return
    }

    setLoadingForNode(contextMenuNode.id, true)
    getPersonaCritique(rqData, personaData, ancestorNodesWithDepth)
      .then((result) => {
        console.log("getPersonaCritique: ", result.data)

        // create a new node, and fill the value with the critique
        let [newNodeIDs, newNodes] = createNodeAndConnect(
          "CritiqueNode",
          contextMenuNode.id,
          result.data,
          "None",
        )
      })
      .catch((error) => {
        console.log("getPersonaCritique: ", error)
      })
      .finally(() => {
        setLoadingForNode(contextMenuNode.id, false)
        setCurrentStep(currentStep + 1)
      })
  }

  const generateRQFromCritique = () => {
    setIsNodeMenuOpen(false)

    const critiqueData: CritiqueNodeData = {
      critique_aspect: contextMenuNode.data.node.template.critique_aspect.value,
      critique_detail: contextMenuNode.data.node.template.critique_detail.value,
    }

    // const incomer_nodes = getIncomers(contextMenuNode, reactFlowInstance.getNodes(), reactFlowInstance.getEdges());
    // const incomer_rq_nodes = incomer_nodes.filter((node: Node) => node.data.type === "RQNode");

    const ancestorNodesWithDepth = getNodeAllAncestors(contextMenuNode)
    const ancestorNodes = ancestorNodesWithDepth.map((item) => item.node)
    const ancestorRQNodes = ancestorNodes.filter(
      (node) => node.data.type === "RQNode",
    )

    if (ancestorRQNodes.length === 0) {
      console.log("no rq node found")

      return
    }
    const rq_node = ancestorRQNodes[0]
    const rq_data = {
      rq_text: rq_node.data.userInput,
    } as NodeData

    setLoadingForNode(contextMenuNode.id, true)
    getCritiqueRQ(rq_data, [critiqueData])
      .then((result) => {
        console.log("getCritiqueRQ: ", result.data)

        // create a new node, and fill the value with the critique
        let [newNodeIDs, newNodes] = createNodeAndConnect(
          "RQNode",
          contextMenuNode.id,
          result.data,
          "None",
        )
      })
      .catch((error) => {
        console.log("getPersonaCritique: ", error)
      })
      .finally(() => {
        setLoadingForNode(contextMenuNode.id, false)
        setCurrentStep(currentStep + 1)
      })
  }

  const handleNext = () => {
    if (currentStep === 0) {
      generateRQ()
      setCurrentStep(currentStep + 1)
    } else if (currentStep === 1) {
      setCurrentStep(currentStep + 1)
    } else if (currentStep === 2) {
      setCurrentStep(currentStep + 1)
    } else if (currentStep === 3) {
      generatePersonaFromRQ()
    } else if (currentStep === 4) {
      setCurrentStep(currentStep + 1)
    } else if (currentStep === 5) {
      generateLitNodesFromPersona()
    } else if (currentStep === 6) {
      setCurrentStep(currentStep + 1)
    } else if (currentStep === 7) {
      setCurrentStep(currentStep + 1)
    } else if (currentStep === 8) {
      generateCritiqueFromLiterature()
    } else if (currentStep === 9) {
      setCurrentStep(currentStep + 1)
    } else if (currentStep === 10) {
      generateRQFromCritique()
    } else if (currentStep === 11) {
      setCurrentStep(currentStep + 1)
    } else if (currentStep === 12) {
      setCurrentStep(currentStep + 1)
    }
  }

  useEffect(() => {
    if (currentNode?.data?.type === "RQNode") {
      setContextMenuNode(currentNode)
    }
    if (currentNode?.data?.type === "PersonaNode") {
      setContextMenuNode(currentNode)
    }
    if (currentNode?.data?.type === "LiteratureNode") {
      setContextMenuNode(currentNode)
    }
    if (currentNode?.data?.type === "CritiqueNode") {
      setContextMenuNode(currentNode)
    }
  }, [currentNode])

  // useEffect(() => {
  //   if (isInteractiveTutorialOpen && currentStep === targetTutorialStep) {
  //     handleOpen()
  //   }
  // }, [currentStep, isInteractiveTutorialOpen])

  return (
    <>
      {/* {isInteractiveTutorialOpen && (
        // <Backdrop
        //   sx={{
        //     color: "#fff",
        //     zIndex: (theme) => theme.zIndex.drawer + 4,
        //   }}
        //   open={true}
        // ></Backdrop>
      )} */}
      <Tooltip
        arrow
        placement="right"
        open={
          isInteractiveTutorialOpen &&
          (targetNodeIds.length === 0 ||
            (childNodeId ? targetNodeIds.includes(childNodeId) : false) ||
            currentStep === 7 ||
            currentStep === 12)
        }
        title={
          <Box
            className="flex flex-col gap-2 justify-center items-center"
            sx={{
              padding: "1rem",
            }}
          >
            <Typography
              gutterBottom
              align="center"
              sx={{ fontWeight: "medium" }}
            >
              {interactiveTutorialSteps[currentStep]?.title}
            </Typography>
            <Button
              size="small"
              variant="contained"
              color="primary"
              onClick={handleNext}
            >
              Next
            </Button>
          </Box>
        }
      >
        <Box
          sx={{
            zIndex: (theme) => theme.zIndex.drawer + 2,
            position: "relative",
            backgroundColor: "white",
            borderRadius: "10px",
            padding: "1rem",
          }}
        >
          {children}
        </Box>
      </Tooltip>
    </>
  )
}
